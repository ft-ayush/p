<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport"/>
    <meta content="pdoc 0.9.1" name="generator"/>
    <title>lib.solver API documentation</title>
    <meta content="" name="description"/>
    <link as="style" crossorigin href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
          integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" rel="preload stylesheet">
    <link as="style" crossorigin
          href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
          integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" rel="preload stylesheet">
    <link as="style" crossorigin href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css"
          rel="stylesheet preload">
    <style>
        :root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}
    </style>
    <style media="screen and (min-width: 700px)">
        @media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}
    </style>
    <style media="print">
        @media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}
    </style>
    <script crossorigin defer integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8="
            src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
    <script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
    <article id="content">
        <header>
            <h1 class="title">Module <code>lib.solver</code></h1>
        </header>
        <section id="section-intro">
            <details class="source">
                <summary>
                    <span>Expand source code</span>
                </summary>
                <pre><code class="python">import time

from lib.board import Board
from queue import PriorityQueue, Queue, LifoQueue

&#34;&#34;&#34;
Solver class that takes in Board and perform 
A* to solve it
Priority queue uses Min Heap which will return 
the value of the Min Priority which points to 
min distance required to solve the puzzle.
So moves are picked directly by Queue.
&#34;&#34;&#34;


class PuzzleSolver:
    def __init__(self, n=3):
        &#34;&#34;&#34;
        Solver class to solve for 3 algorithms

            &#39;A*&#39; : A start using Priority Queue
            &#39;BFS&#39; : Breadth first search using Queue FIFO
            &#39;DFS&#39; : Depth first search using Queue LIFO

        Parameters
        ----------
        n : int, default=3
            dimension of board

        Attributes
        ----------
        boardList : list
            initial list of Start state numbers
        n : int
            dimension of board
        goalState : list, optional
            goal state of the board
        &#34;&#34;&#34;
        self.boardList = []
        self.n = n
        self.goalState = None

    def solveAStart(self):
        &#34;&#34;&#34;
        Solve function, read the neighbours
        append the dist and moves to the queue
        Queue picks small distances and puzzle is
        solved
        &#34;&#34;&#34;
        startTime = time.time()
        board = Board(self.boardList, goalState=self.goalState, n=self.n)
        print(&#34;Start State .............&#34;)
        print(board)

        goal = Board(board.goalState, goalState=None, n=self.n)
        print(&#34;Goal State ..............&#34;)
        print(goal)

        queue = PriorityQueue()
        queue.put(board.getPriority(0))
        i = 1

        while not queue.empty():
            board = queue.get()[2]
            if not board.isGoal():
                for neighbour in board.getNeighbours():
                    if neighbour != board.previous:
                        queue.put(neighbour.getPriority(i))
                        i += 1
            else:
                self.analytics(&#34;A star&#34;, board.move, i, time.time() - startTime, board)
                return

    def solveBFS(self):
        &#34;&#34;&#34;
        Solve function for BFS algorithm
        &#34;&#34;&#34;
        startTime = time.time()
        board = Board(self.boardList, goalState=self.goalState, n=self.n)

        visited = list()
        queue = Queue()
        queue.put(board.getPriority(0)[2])
        i = 1

        while not queue.empty():
            board = queue.get()
            if not board.isGoal():
                for neighbour in board.getNeighbours():
                    if neighbour not in visited:
                        visited.append(neighbour)
                        queue.put(neighbour)
                        i += 1
            else:
                self.analytics(&#34;BFS&#34;, board.move, i, time.time() - startTime, board)
                return

    def solveDFS(self):
        &#34;&#34;&#34;
        Solve function for DFS algorithm
        &#34;&#34;&#34;
        startTime = time.time()
        board = Board(self.boardList, goalState=self.goalState, n=self.n)

        visited = list()
        queue = LifoQueue()
        queue.put(board.getPriority(0)[2])
        i = 1

        while not queue.empty():
            board = queue.get()
            if not board.isGoal():
                for neighbour in board.getNeighbours():
                    if neighbour not in visited:
                        visited.append(neighbour)
                        queue.put(neighbour)
                        i += 1
            else:
                self.analytics(&#34;DFS&#34;, board.move, i, time.time() - startTime, board)
                return

    def start(self, goalState=False):
        &#34;&#34;&#34;
        if goal state is false, it will create a default state
        else the output will be as per the goal state

        Parameters
        ----------
        goalState : bool
            if goalState is True, then the function will read the Goal State
        &#34;&#34;&#34;
        # print(&#34;Enter input board&#34;)
        for i in range(0, self.n * self.n):
            self.boardList.append(int(input()))

        if goalState:
            self.goalState = []
            # print(&#34;Enter goal board (including space)&#34;)
            for i in range(0, self.n * self.n):
                self.goalState.append(int(input()))

        return self

    def analytics(self, method, moves, steps, executionTime, board):
        &#34;&#34;&#34;
        Printing final analytics for the algorithm

        Parameters
        ----------
        method : str
            name of the algorithm
        moves : int
            number of moves required
        steps : int
            number of sequences solved / visited
        executionTime : float
            time required to get to the goal state in secs
        board : object
            final board

        Returns
        -------

        &#34;&#34;&#34;
        print(&#34;**************************************&#34;)
        print(f&#34;Algorithm name :: {method}&#34;)
        print(f&#34;Total optimal moves to solve :: {moves}&#34;)
        print(f&#34;Total steps required to get to Goal :: {steps}&#34;)
        print(f&#34;Time required to find the Goal state :: {round(executionTime, 3)} s&#34;)
        print(board)
        print(&#34;**************************************&#34;)</code></pre>
            </details>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
        </section>
        <section>
            <h2 class="section-title" id="header-classes">Classes</h2>
            <dl>
                <dt id="lib.solver.PuzzleSolver"><code class="flex name class">
                    <span>class <span class="ident">PuzzleSolver</span></span>
                    <span>(</span><span>n=3)</span>
                </code></dt>
                <dd>
                    <div class="desc"><p>Solver class to solve for 3 algorithms</p>
                        <pre><code>'A*' : A start using Priority Queue
'BFS' : Breadth first search using Queue FIFO
'DFS' : Depth first search using Queue LIFO
</code></pre>
                        <h2 id="parameters">Parameters</h2>
                        <dl>
                            <dt><strong><code>n</code></strong> :&ensp;<code>int</code>, default=<code>3</code></dt>
                            <dd>dimension of board</dd>
                        </dl>
                        <h2 id="attributes">Attributes</h2>
                        <dl>
                            <dt><strong><code>boardList</code></strong> :&ensp;<code>list</code></dt>
                            <dd>initial list of Start state numbers</dd>
                            <dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
                            <dd>dimension of board</dd>
                            <dt><strong><code>goalState</code></strong> :&ensp;<code>list</code>, optional</dt>
                            <dd>goal state of the board</dd>
                        </dl>
                    </div>
                    <details class="source">
                        <summary>
                            <span>Expand source code</span>
                        </summary>
                        <pre><code class="python">class PuzzleSolver:
    def __init__(self, n=3):
        &#34;&#34;&#34;
        Solver class to solve for 3 algorithms

            &#39;A*&#39; : A start using Priority Queue
            &#39;BFS&#39; : Breadth first search using Queue FIFO
            &#39;DFS&#39; : Depth first search using Queue LIFO

        Parameters
        ----------
        n : int, default=3
            dimension of board

        Attributes
        ----------
        boardList : list
            initial list of Start state numbers
        n : int
            dimension of board
        goalState : list, optional
            goal state of the board
        &#34;&#34;&#34;
        self.boardList = []
        self.n = n
        self.goalState = None

    def solveAStart(self):
        &#34;&#34;&#34;
        Solve function, read the neighbours
        append the dist and moves to the queue
        Queue picks small distances and puzzle is
        solved
        &#34;&#34;&#34;
        startTime = time.time()
        board = Board(self.boardList, goalState=self.goalState, n=self.n)
        print(&#34;Start State .............&#34;)
        print(board)

        goal = Board(board.goalState, goalState=None, n=self.n)
        print(&#34;Goal State ..............&#34;)
        print(goal)

        queue = PriorityQueue()
        queue.put(board.getPriority(0))
        i = 1

        while not queue.empty():
            board = queue.get()[2]
            if not board.isGoal():
                for neighbour in board.getNeighbours():
                    if neighbour != board.previous:
                        queue.put(neighbour.getPriority(i))
                        i += 1
            else:
                self.analytics(&#34;A star&#34;, board.move, i, time.time() - startTime, board)
                return

    def solveBFS(self):
        &#34;&#34;&#34;
        Solve function for BFS algorithm
        &#34;&#34;&#34;
        startTime = time.time()
        board = Board(self.boardList, goalState=self.goalState, n=self.n)

        visited = list()
        queue = Queue()
        queue.put(board.getPriority(0)[2])
        i = 1

        while not queue.empty():
            board = queue.get()
            if not board.isGoal():
                for neighbour in board.getNeighbours():
                    if neighbour not in visited:
                        visited.append(neighbour)
                        queue.put(neighbour)
                        i += 1
            else:
                self.analytics(&#34;BFS&#34;, board.move, i, time.time() - startTime, board)
                return

    def solveDFS(self):
        &#34;&#34;&#34;
        Solve function for DFS algorithm
        &#34;&#34;&#34;
        startTime = time.time()
        board = Board(self.boardList, goalState=self.goalState, n=self.n)

        visited = list()
        queue = LifoQueue()
        queue.put(board.getPriority(0)[2])
        i = 1

        while not queue.empty():
            board = queue.get()
            if not board.isGoal():
                for neighbour in board.getNeighbours():
                    if neighbour not in visited:
                        visited.append(neighbour)
                        queue.put(neighbour)
                        i += 1
            else:
                self.analytics(&#34;DFS&#34;, board.move, i, time.time() - startTime, board)
                return

    def start(self, goalState=False):
        &#34;&#34;&#34;
        if goal state is false, it will create a default state
        else the output will be as per the goal state

        Parameters
        ----------
        goalState : bool
            if goalState is True, then the function will read the Goal State
        &#34;&#34;&#34;
        # print(&#34;Enter input board&#34;)
        for i in range(0, self.n * self.n):
            self.boardList.append(int(input()))

        if goalState:
            self.goalState = []
            # print(&#34;Enter goal board (including space)&#34;)
            for i in range(0, self.n * self.n):
                self.goalState.append(int(input()))

        return self

    def analytics(self, method, moves, steps, executionTime, board):
        &#34;&#34;&#34;
        Printing final analytics for the algorithm

        Parameters
        ----------
        method : str
            name of the algorithm
        moves : int
            number of moves required
        steps : int
            number of sequences solved / visited
        executionTime : float
            time required to get to the goal state in secs
        board : object
            final board

        Returns
        -------

        &#34;&#34;&#34;
        print(&#34;**************************************&#34;)
        print(f&#34;Algorithm name :: {method}&#34;)
        print(f&#34;Total optimal moves to solve :: {moves}&#34;)
        print(f&#34;Total steps required to get to Goal :: {steps}&#34;)
        print(f&#34;Time required to find the Goal state :: {round(executionTime, 3)} s&#34;)
        print(board)
        print(&#34;**************************************&#34;)</code></pre>
                    </details>
                    <h3>Methods</h3>
                    <dl>
                        <dt id="lib.solver.PuzzleSolver.analytics"><code class="name flex">
                            <span>def <span class="ident">analytics</span></span>(<span>self, method, moves, steps, executionTime, board)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Printing final analytics for the algorithm</p>
                                <h2 id="parameters">Parameters</h2>
                                <dl>
                                    <dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
                                    <dd>name of the algorithm</dd>
                                    <dt><strong><code>moves</code></strong> :&ensp;<code>int</code></dt>
                                    <dd>number of moves required</dd>
                                    <dt><strong><code>steps</code></strong> :&ensp;<code>int</code></dt>
                                    <dd>number of sequences solved / visited</dd>
                                    <dt><strong><code>executionTime</code></strong> :&ensp;<code>float</code></dt>
                                    <dd>time required to get to the goal state in secs</dd>
                                    <dt><strong><code>board</code></strong> :&ensp;<code>object</code></dt>
                                    <dd>final board</dd>
                                </dl>
                                <h2 id="returns">Returns</h2></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def analytics(self, method, moves, steps, executionTime, board):
    &#34;&#34;&#34;
    Printing final analytics for the algorithm

    Parameters
    ----------
    method : str
        name of the algorithm
    moves : int
        number of moves required
    steps : int
        number of sequences solved / visited
    executionTime : float
        time required to get to the goal state in secs
    board : object
        final board

    Returns
    -------

    &#34;&#34;&#34;
    print(&#34;**************************************&#34;)
    print(f&#34;Algorithm name :: {method}&#34;)
    print(f&#34;Total optimal moves to solve :: {moves}&#34;)
    print(f&#34;Total steps required to get to Goal :: {steps}&#34;)
    print(f&#34;Time required to find the Goal state :: {round(executionTime, 3)} s&#34;)
    print(board)
    print(&#34;**************************************&#34;)</code></pre>
                            </details>
                        </dd>
                        <dt id="lib.solver.PuzzleSolver.solveAStart"><code class="name flex">
                            <span>def <span class="ident">solveAStart</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Solve function, read the neighbours
                                append the dist and moves to the queue
                                Queue picks small distances and puzzle is
                                solved</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def solveAStart(self):
    &#34;&#34;&#34;
    Solve function, read the neighbours
    append the dist and moves to the queue
    Queue picks small distances and puzzle is
    solved
    &#34;&#34;&#34;
    startTime = time.time()
    board = Board(self.boardList, goalState=self.goalState, n=self.n)
    print(&#34;Start State .............&#34;)
    print(board)

    goal = Board(board.goalState, goalState=None, n=self.n)
    print(&#34;Goal State ..............&#34;)
    print(goal)

    queue = PriorityQueue()
    queue.put(board.getPriority(0))
    i = 1

    while not queue.empty():
        board = queue.get()[2]
        if not board.isGoal():
            for neighbour in board.getNeighbours():
                if neighbour != board.previous:
                    queue.put(neighbour.getPriority(i))
                    i += 1
        else:
            self.analytics(&#34;A star&#34;, board.move, i, time.time() - startTime, board)
            return</code></pre>
                            </details>
                        </dd>
                        <dt id="lib.solver.PuzzleSolver.solveBFS"><code class="name flex">
                            <span>def <span class="ident">solveBFS</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Solve function for BFS algorithm</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def solveBFS(self):
    &#34;&#34;&#34;
    Solve function for BFS algorithm
    &#34;&#34;&#34;
    startTime = time.time()
    board = Board(self.boardList, goalState=self.goalState, n=self.n)

    visited = list()
    queue = Queue()
    queue.put(board.getPriority(0)[2])
    i = 1

    while not queue.empty():
        board = queue.get()
        if not board.isGoal():
            for neighbour in board.getNeighbours():
                if neighbour not in visited:
                    visited.append(neighbour)
                    queue.put(neighbour)
                    i += 1
        else:
            self.analytics(&#34;BFS&#34;, board.move, i, time.time() - startTime, board)
            return</code></pre>
                            </details>
                        </dd>
                        <dt id="lib.solver.PuzzleSolver.solveDFS"><code class="name flex">
                            <span>def <span class="ident">solveDFS</span></span>(<span>self)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>Solve function for DFS algorithm</p></div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def solveDFS(self):
    &#34;&#34;&#34;
    Solve function for DFS algorithm
    &#34;&#34;&#34;
    startTime = time.time()
    board = Board(self.boardList, goalState=self.goalState, n=self.n)

    visited = list()
    queue = LifoQueue()
    queue.put(board.getPriority(0)[2])
    i = 1

    while not queue.empty():
        board = queue.get()
        if not board.isGoal():
            for neighbour in board.getNeighbours():
                if neighbour not in visited:
                    visited.append(neighbour)
                    queue.put(neighbour)
                    i += 1
        else:
            self.analytics(&#34;DFS&#34;, board.move, i, time.time() - startTime, board)
            return</code></pre>
                            </details>
                        </dd>
                        <dt id="lib.solver.PuzzleSolver.start"><code class="name flex">
                            <span>def <span class="ident">start</span></span>(<span>self, goalState=False)</span>
                        </code></dt>
                        <dd>
                            <div class="desc"><p>if goal state is false, it will create a default state
                                else the output will be as per the goal state</p>
                                <h2 id="parameters">Parameters</h2>
                                <dl>
                                    <dt><strong><code>goalState</code></strong> :&ensp;<code>bool</code></dt>
                                    <dd>if goalState is True, then the function will read the Goal State</dd>
                                </dl>
                            </div>
                            <details class="source">
                                <summary>
                                    <span>Expand source code</span>
                                </summary>
                                <pre><code class="python">def start(self, goalState=False):
    &#34;&#34;&#34;
    if goal state is false, it will create a default state
    else the output will be as per the goal state

    Parameters
    ----------
    goalState : bool
        if goalState is True, then the function will read the Goal State
    &#34;&#34;&#34;
    # print(&#34;Enter input board&#34;)
    for i in range(0, self.n * self.n):
        self.boardList.append(int(input()))

    if goalState:
        self.goalState = []
        # print(&#34;Enter goal board (including space)&#34;)
        for i in range(0, self.n * self.n):
            self.goalState.append(int(input()))

    return self</code></pre>
                            </details>
                        </dd>
                    </dl>
                </dd>
            </dl>
        </section>
    </article>
    <nav id="sidebar">
        <h1>Index</h1>
        <div class="toc">
            <ul></ul>
        </div>
        <ul id="index">
            <li><h3>Super-module</h3>
                <ul>
                    <li><code><a href="index.html" title="lib">lib</a></code></li>
                </ul>
            </li>
            <li><h3><a href="#header-classes">Classes</a></h3>
                <ul>
                    <li>
                        <h4><code><a href="#lib.solver.PuzzleSolver"
                                     title="lib.solver.PuzzleSolver">PuzzleSolver</a></code></h4>
                        <ul class="">
                            <li><code><a href="#lib.solver.PuzzleSolver.analytics"
                                         title="lib.solver.PuzzleSolver.analytics">analytics</a></code></li>
                            <li><code><a href="#lib.solver.PuzzleSolver.solveAStart"
                                         title="lib.solver.PuzzleSolver.solveAStart">solveAStart</a></code></li>
                            <li><code><a href="#lib.solver.PuzzleSolver.solveBFS"
                                         title="lib.solver.PuzzleSolver.solveBFS">solveBFS</a></code></li>
                            <li><code><a href="#lib.solver.PuzzleSolver.solveDFS"
                                         title="lib.solver.PuzzleSolver.solveDFS">solveDFS</a></code></li>
                            <li><code><a href="#lib.solver.PuzzleSolver.start" title="lib.solver.PuzzleSolver.start">start</a></code>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </nav>
</main>
<footer id="footer">
    <p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>